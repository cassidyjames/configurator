/* SelectInput.c generated by valac 0.34.9, the Vala compiler
 * generated from SelectInput.vala, do not modify */

/* Copyright 2015 Marcus Wichelmann
*
* This file is part of Configurator.
*
* Configurator is free software: you can redistribute it
* and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation, either version 3 of the
* License, or (at your option) any later version.
*
* Configurator is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without Configurator the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
* Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with Configurator. If not, see http://www.gnu.org/licenses/.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>


#define CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT (configurator_widgets_fields_select_input_get_type ())
#define CONFIGURATOR_WIDGETS_FIELDS_SELECT_INPUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT, configuratorWidgetsFieldsSelectInput))
#define CONFIGURATOR_WIDGETS_FIELDS_SELECT_INPUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT, configuratorWidgetsFieldsSelectInputClass))
#define CONFIGURATOR_WIDGETS_FIELDS_IS_SELECT_INPUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT))
#define CONFIGURATOR_WIDGETS_FIELDS_IS_SELECT_INPUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT))
#define CONFIGURATOR_WIDGETS_FIELDS_SELECT_INPUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT, configuratorWidgetsFieldsSelectInputClass))

typedef struct _configuratorWidgetsFieldsSelectInput configuratorWidgetsFieldsSelectInput;
typedef struct _configuratorWidgetsFieldsSelectInputClass configuratorWidgetsFieldsSelectInputClass;
typedef struct _configuratorWidgetsFieldsSelectInputPrivate configuratorWidgetsFieldsSelectInputPrivate;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _configuratorWidgetsFieldsSelectInput {
	GtkComboBoxText parent_instance;
	configuratorWidgetsFieldsSelectInputPrivate * priv;
};

struct _configuratorWidgetsFieldsSelectInputClass {
	GtkComboBoxTextClass parent_class;
};


static gpointer configurator_widgets_fields_select_input_parent_class = NULL;

GType configurator_widgets_fields_select_input_get_type (void) G_GNUC_CONST;
enum  {
	CONFIGURATOR_WIDGETS_FIELDS_SELECT_INPUT_DUMMY_PROPERTY
};
configuratorWidgetsFieldsSelectInput* configurator_widgets_fields_select_input_new (GVariant* options);
configuratorWidgetsFieldsSelectInput* configurator_widgets_fields_select_input_construct (GType object_type, GVariant* options);


configuratorWidgetsFieldsSelectInput* configurator_widgets_fields_select_input_construct (GType object_type, GVariant* options) {
	configuratorWidgetsFieldsSelectInput * self = NULL;
	g_return_val_if_fail (options != NULL, NULL);
	self = (configuratorWidgetsFieldsSelectInput*) g_object_new (object_type, NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_ = 0;
				GVariant* _tmp3_ = NULL;
				gsize _tmp4_ = 0UL;
				gchar* option = NULL;
				GVariant* _tmp5_ = NULL;
				gint _tmp6_ = 0;
				GVariant* _tmp7_ = NULL;
				GVariant* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				_tmp3_ = options;
				_tmp4_ = g_variant_n_children (_tmp3_);
				if (!(((gsize) _tmp2_) < _tmp4_)) {
					break;
				}
				_tmp5_ = options;
				_tmp6_ = i;
				_tmp7_ = g_variant_get_child_value (_tmp5_, (gsize) _tmp6_);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_variant_get_string (_tmp8_, NULL);
				_tmp10_ = g_strdup (_tmp9_);
				_tmp11_ = _tmp10_;
				_g_variant_unref0 (_tmp8_);
				option = _tmp11_;
				_tmp12_ = option;
				_tmp13_ = option;
				gtk_combo_box_text_append ((GtkComboBoxText*) self, _tmp12_, _tmp13_);
				_g_free0 (option);
			}
		}
	}
	return self;
}


configuratorWidgetsFieldsSelectInput* configurator_widgets_fields_select_input_new (GVariant* options) {
	return configurator_widgets_fields_select_input_construct (CONFIGURATOR_WIDGETS_FIELDS_TYPE_SELECT_INPUT, options);
}


static void configurator_widgets_fields_select_input_class_init (configuratorWidgetsFieldsSelectInputClass * klass) {
	configurator_widgets_fields_select_input_parent_class = g_type_class_peek_parent (klass);
}


static void configurator_widgets_fields_select_input_instance_init (configuratorWidgetsFieldsSelectInput * self) {
}


GType configurator_widgets_fields_select_input_get_type (void) {
	static volatile gsize configurator_widgets_fields_select_input_type_id__volatile = 0;
	if (g_once_init_enter (&configurator_widgets_fields_select_input_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (configuratorWidgetsFieldsSelectInputClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) configurator_widgets_fields_select_input_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (configuratorWidgetsFieldsSelectInput), 0, (GInstanceInitFunc) configurator_widgets_fields_select_input_instance_init, NULL };
		GType configurator_widgets_fields_select_input_type_id;
		configurator_widgets_fields_select_input_type_id = g_type_register_static (gtk_combo_box_text_get_type (), "configuratorWidgetsFieldsSelectInput", &g_define_type_info, 0);
		g_once_init_leave (&configurator_widgets_fields_select_input_type_id__volatile, configurator_widgets_fields_select_input_type_id);
	}
	return configurator_widgets_fields_select_input_type_id__volatile;
}



